use crate::parse::*;

grammar(module_id: DefId, search_dir: &std::path::Path, repo: &mut Repository);

Path: Path = {
  Identifier  => vec![<>],
  <mut v:Path> "::" <i:Identifier> => {
    v.push(i);
    v
  }
};

// Types

TypeName: Ty = {
  "Bool"      => Ty::Bool,
  "Uint8"     => Ty::Uint8,
  "Int8"      => Ty::Int8,
  "Uint16"    => Ty::Uint16,
  "Int16"     => Ty::Int16,
  "Uint32"    => Ty::Uint32,
  "Int32"     => Ty::Int32,
  "Uint64"    => Ty::Uint64,
  "Int64"     => Ty::Int64,
  "Uintn"     => Ty::Uintn,
  "Intn"      => Ty::Intn,
  "Float"     => Ty::Float,
  "Double"    => Ty::Double,
  <path:Path> <type_args:TypeArgumentListOpt> => Ty::Inst(path, type_args),
  "*" <is_mut:IsMut> <ty:TypeName> =>
    Ty::Ptr(is_mut, Box::new(ty)),
  "Function" "(" <params:ParameterListOpt> ")" <ret:ReturnType> =>
    Ty::Func(params, Box::new(ret)),
  "[" <l:Expr> "]" <t:TypeName> =>
    Ty::Arr(Box::new(l), Box::new(t)),
  "(" <params:ParameterListOpt>  ")" =>
    Ty::Tuple(params)
};

TypeArgumentListOpt: Vec<Ty> = {
  "<" <list:TypeArgumentList> ">" => list,
  => vec![],
};

TypeArgumentList: Vec<Ty> = {
  TypeName => vec![<>],
  <mut list:TypeArgumentList> "," <ty:TypeName> => {
    list.push(ty);
    list
  }
};

ParameterListOpt: Vec<(RefStr, Ty)> = {
  ParameterList,
  => vec![],
};

ParameterList: Vec<(RefStr, Ty)> = {
  <name:Identifier> ":" <ty:TypeName> => vec![ (name, ty) ],
  <mut l:ParameterList> "," <name:Identifier> ":" <ty:TypeName> => {
    l.push((name, ty));
    l
  },
};

ReturnType: Ty = {
  "->" <t:TypeName> => t,
  => Ty::Tuple(vec![])
};

IsMut: IsMut = {
  "mut" => IsMut::Yes,
        => IsMut::No
};

// Blocks

Block: Expr = {
  "{" "}" => Expr::Null,
  "{" <v:BlockItemList> "}" => Expr::Block(v),
  "{" <mut v:BlockItemList> ";" "}" => {
    v.push(Expr::Null);
    Expr::Block(v)
  }
};

BlockItemList: Vec<Expr> = {
  BlockItem => vec![<>],
  <mut v:BlockItemList> ";" <i:BlockItem> => {
    v.push(i);
    v
  }
};

BlockItem: Expr = {
  Expr,
  "let" <is_mut:IsMut> <name:Identifier> <ty:LetType> "=" <init:Expr> =>
    Expr::Let(name, is_mut, ty, Some(Box::new(init))),
  "let" <is_mut:IsMut> <name:Identifier> <ty:LetType> "=" "!" =>
    Expr::Let(name, is_mut, ty, None),
  "continue" => Expr::Continue,
  "break" <e:ExprOpt> => Expr::Break(Box::new(e)),
  "return" <e:ExprOpt> => Expr::Return(Box::new(e)),
  "if" <e:Expr> <b:Block> => Expr::If(Box::new(e), Box::new(b), Box::new(Expr::Null)),
  "while" <e:Expr> <b:Block> => Expr::While(Box::new(e), Box::new(b)),

  <l:Expr> "=" <r:Expr> => Expr::As(Box::new(l), Box::new(r)),
  <l:Expr> "*=" <r:Expr> => Expr::Rmw(BinOp::Mul, Box::new(l), Box::new(r)),
  <l:Expr> "/=" <r:Expr> => Expr::Rmw(BinOp::Div, Box::new(l), Box::new(r)),
  <l:Expr> "%=" <r:Expr> => Expr::Rmw(BinOp::Mod, Box::new(l), Box::new(r)),
  <l:Expr> "+=" <r:Expr> => Expr::Rmw(BinOp::Add, Box::new(l), Box::new(r)),
  <l:Expr> "-=" <r:Expr> => Expr::Rmw(BinOp::Sub, Box::new(l), Box::new(r)),
  <l:Expr> "<<=" <r:Expr> => Expr::Rmw(BinOp::Lsh, Box::new(l), Box::new(r)),
  <l:Expr> ">>=" <r:Expr> => Expr::Rmw(BinOp::Rsh, Box::new(l), Box::new(r)),
  <l:Expr> "&=" <r:Expr> => Expr::Rmw(BinOp::And, Box::new(l), Box::new(r)),
  <l:Expr> "^=" <r:Expr> => Expr::Rmw(BinOp::Xor, Box::new(l), Box::new(r)),
  <l:Expr> "|=" <r:Expr> => Expr::Rmw(BinOp::Or, Box::new(l), Box::new(r)),
};

ExprOpt: Expr = {
  <e:Expr>  => e,
            => Expr::Null
};

LetType: Option<Ty> = {
  ":" <ty:TypeName> => Some(ty),
                    => None,
};

// Expressions

Expr: Expr = {
  LOrExpr,
  IfExpr,
  "loop" <b:Block> => Expr::Loop(Box::new(b))
};

IfExpr: Expr = {
  "if" <c:Expr> <t:Block> "else" <e:Block> => Expr::If(Box::new(c), Box::new(t), Box::new(e)),
  "if" <c:Expr> <t:Block> "else" <e:IfExpr> => Expr::If(Box::new(c), Box::new(t), Box::new(e)),
};

LOrExpr: Expr = {
  LAndExpr,
  <l:LOrExpr> "||" <r:LAndExpr> => Expr::LOr(Box::new(l), Box::new(r))
};

LAndExpr: Expr = {
  CmpExpr,
  <l:LAndExpr> "&&" <r:CmpExpr> => Expr::LAnd(Box::new(l), Box::new(r))
};

CmpExpr: Expr = {
  OrExpr,
  <l:OrExpr> "==" <r:OrExpr> => Expr::Bin(BinOp::Eq, Box::new(l), Box::new(r)),
  <l:OrExpr> "!=" <r:OrExpr> => Expr::Bin(BinOp::Ne, Box::new(l), Box::new(r)),
  <l:OrExpr> "<" <r:OrExpr> => Expr::Bin(BinOp::Lt, Box::new(l), Box::new(r)),
  <l:OrExpr> ">" <r:OrExpr> => Expr::Bin(BinOp::Gt, Box::new(l), Box::new(r)),
  <l:OrExpr> "<=" <r:OrExpr> => Expr::Bin(BinOp::Le, Box::new(l), Box::new(r)),
  <l:OrExpr> ">=" <r:OrExpr> => Expr::Bin(BinOp::Ge, Box::new(l), Box::new(r)),
};

OrExpr: Expr = {
  XorExpr,
  <l:OrExpr> "|" <r:XorExpr> => Expr::Bin(BinOp::Or, Box::new(l), Box::new(r))
};

XorExpr: Expr = {
  AndExpr,
  <l:XorExpr> "^" <r:AndExpr> => Expr::Bin(BinOp::Xor, Box::new(l), Box::new(r))
};

AndExpr: Expr = {
  ShiftExpr,
  <l:AndExpr> "&" <r:ShiftExpr> => Expr::Bin(BinOp::And, Box::new(l), Box::new(r))
};

ShiftExpr: Expr = {
  AddExpr,
  <l:ShiftExpr> "<<" <r:AddExpr> => Expr::Bin(BinOp::Lsh, Box::new(l), Box::new(r)),
  <l:ShiftExpr> ">>" <r:AddExpr> => Expr::Bin(BinOp::Rsh, Box::new(l), Box::new(r)),
};

AddExpr: Expr = {
  MulExpr,
  <l:AddExpr> "+" <r:MulExpr> => Expr::Bin(BinOp::Add, Box::new(l), Box::new(r)),
  <l:AddExpr> "-" <r:MulExpr> => Expr::Bin(BinOp::Sub, Box::new(l), Box::new(r)),
};

MulExpr: Expr = {
  CastExpr,
  <l:MulExpr> "*" <r:CastExpr> => Expr::Bin(BinOp::Mul, Box::new(l), Box::new(r)),
  <l:MulExpr> "/" <r:CastExpr> => Expr::Bin(BinOp::Div, Box::new(l), Box::new(r)),
  <l:MulExpr> "%" <r:CastExpr> => Expr::Bin(BinOp::Mod, Box::new(l), Box::new(r)),
};

CastExpr: Expr = {
  PreExpr,
  //<expr:CastExpr> "as" <ty:TypeName> => Expr::Cast(Box::new(expr), ty),
};

PreExpr: Expr = {
  PostExpr,
  "&" <e:PreExpr> => Expr::Adr(Box::new(e)),
  "*" <e:PreExpr> => Expr::Ind(Box::new(e)),
  "+" <e:PreExpr> => Expr::Un(UnOp::UPlus, Box::new(e)),
  "-" <e:PreExpr> => Expr::Un(UnOp::UMinus, Box::new(e)),
  "~" <e:PreExpr> => Expr::Un(UnOp::Not, Box::new(e)),
  "!" <e:PreExpr> => Expr::LNot(Box::new(e)),
};

PostExpr: Expr = {
  PrimExpr,
  <e:PostExpr> "." <i:Identifier> => Expr::Dot(Box::new(e), i),
  <e:PostExpr> "(" <a:ArgumentListOpt> ")" => Expr::Call(Box::new(e), a),
  <e:PostExpr> "[" <i:Expr> "]" => Expr::Index(Box::new(e), Box::new(i)),
};

ArgumentListOpt: Vec<(RefStr, Expr)> = {
  ArgumentList,
  => vec![],
}

ArgumentList: Vec<(RefStr, Expr)> = {
  Argument => vec![<>],
  <mut args:ArgumentList> "," <arg:Argument> => {
    args.push(arg);
    args
  }
};

Argument: (RefStr, Expr) = {
  Expr => (RefStr::new(""), <>),
  <name:Identifier> ":" <expr:Expr> => (name, expr)
};

PrimExpr: Expr = {
  "(" <e:Expr> ")" => e,
   "[" <list:ArrayExprList> "]" => Expr::Arr(list),
  <b:Block> => b,
  <p:Path> => Expr::Path(p),
  "true" => Expr::Bool(true),
  "false" => Expr::Bool(false),
  Integer => Expr::Int(<>),
  Float => Expr::Flt(<>),
  Character => Expr::Char(<>),
  String => Expr::Str(<>),
  CString => Expr::CStr(<>),
};

ArrayExprList: Vec<Expr> = {
  Expr => vec![<>],
  <mut list:ArrayExprList> "," <expr:Expr> => {
    list.push(expr);
    list
  }
};

// Definitions

TypeDefinition: () = {
  "struct" <name:Identifier> <type_params:TypeParameterListOpt> "(" <params:ParameterListOpt> ")" => {
    let def_id = repo.def(Def::Struct(StructDef { name, type_params, params }));
    repo.sym(module_id, name, def_id);
  },
  "union" <name:Identifier> <type_params:TypeParameterListOpt> "(" <params:ParameterListOpt> ")" => {
    let def_id = repo.def(Def::Union(UnionDef { name, type_params, params }));
    repo.sym(module_id, name, def_id);
  },
  "enum" <name:Identifier> <type_params:TypeParameterListOpt> "(" <variants:VariantListOpt> ")" => {
    let def_id = repo.def(Def::Enum(EnumDef { name, type_params, variants }));
    repo.sym(module_id, name, def_id);
  },
};

TypeParameterListOpt: Vec<RefStr> = {
                             => vec![],
  "<" <l:IdentifierList> ">" => l,
};

IdentifierList: Vec<RefStr> = {
  Identifier => vec![<>],
  <mut l: IdentifierList> "," <i:Identifier> => {
    l.push(i);
    l
  }
};

VariantListOpt: Vec<(RefStr, Variant)> = {
  VariantList,
  => vec![],
};

VariantList: Vec<(RefStr, Variant)> = {
  <v:Variant> => vec![ (v.0, v.1) ],
  <mut l:VariantList> "," <v:Variant> => {
    l.push((v.0, v.1));
    l
  },
};

Variant: (RefStr, Variant) = {
  Identifier => (<>, Variant::Unit),
  <name:Identifier> "(" <params:ParameterListOpt> ")" => (name, Variant::Struct(params)),
};

ConstDefinition: () = {
  "const" <name:Identifier> ":" <ty:TypeName> "=" <val:Expr> => {
    let def_id = repo.def(Def::Const(ConstDef { name, ty, val }));
    repo.sym(module_id, name, def_id);
  }
};

DataDefinition: () = {
  "data" <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> "=" <init:Expr> => {
    let def_id = repo.def(Def::Data(DataDef { name, is_mut, ty, init }));
    repo.sym(module_id, name, def_id);
  }
};

FunctionDefinition: () = {
  "function" <name:Identifier> <type_params:TypeParameterListOpt>
      "(" <params:ParameterDefinitionListOpt> ")" <ret_ty:ReturnType> <body:Block> => {
    let def_id = repo.def(Def::Func(FuncDef { name, type_params, params, ret_ty, body }));
    repo.sym(module_id, name, def_id);
  }
};

ParameterDefinitionListOpt: Vec<(RefStr, IsMut, Ty)> = {
  ParameterDefinitionList,
  => vec![]
};

ParameterDefinitionList: Vec<(RefStr, IsMut, Ty)> = {
  <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    vec![ (name, is_mut, ty) ]
  },
  <mut l:ParameterDefinitionList> "," <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    l.push((name, is_mut, ty));
    l
  },
};

ImportDefinition: () = "import" <name:Identifier> => {
  let imported_module_path = search_dir
    .with_file_name(name.borrow_rs())
    .with_extension("m");
  // FIXME: propagate errors
  let imported_module_id = parse_module(repo, &imported_module_path).unwrap();
  repo.sym(module_id, name, imported_module_id);
};

ExternBlock: () = "extern" "{" Seq<ExternDefinition> "}";

ExternDefinition: () = {
  "function" <name:Identifier> "(" <params:ParameterListOpt> ")" <ret_ty:ReturnType> => {
    let def_id = repo.def(Def::ExternFunc(ExternFuncDef { name, params, varargs: false, ret_ty }));
    repo.sym(module_id, name, def_id);
  },
  "function" <name:Identifier> "(" <params:ParameterList> "," "..." ")" <ret_ty:ReturnType> => {
    let def_id = repo.def(Def::ExternFunc(ExternFuncDef { name, params, varargs: true, ret_ty }));
    repo.sym(module_id, name, def_id);
  },
  "data" <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    let def_id = repo.def(Def::ExternData(ExternDataDef { name, is_mut, ty }));
    repo.sym(module_id, name, def_id);
  }
};

GlobalDefinition: () = {
  TypeDefinition,
  ConstDefinition,
  DataDefinition,
  FunctionDefinition,
  ImportDefinition,
  ExternBlock,
};

pub Module: () = Seq<GlobalDefinition>;

// Tokens

extern {
  type Location = Location;
  type Error = Error;

  enum Token {
    Identifier => lexer::Token::Ident(<RefStr>),
    Integer => lexer::Token::IntLit(<usize>),
    Float => lexer::Token::FltLit(<f64>),
    Character => lexer::Token::CharLit(<Vec<u8>>),
    String => lexer::Token::StrLit(<Vec<u8>>),
    CString => lexer::Token::CStrLit(<Vec<u8>>),
    "Bool" => lexer::Token::TyBool,
    "Uint8" => lexer::Token::TyUint8,
    "Int8" => lexer::Token::TyInt8,
    "Uint16" => lexer::Token::TyUint16,
    "Int16" => lexer::Token::TyInt16,
    "Uint32" => lexer::Token::TyUint32,
    "Int32" => lexer::Token::TyInt32,
    "Uint64" => lexer::Token::TyUint64,
    "Int64" => lexer::Token::TyInt64,
    "Uintn" => lexer::Token::TyUintn,
    "Intn" => lexer::Token::TyIntn,
    "Float" => lexer::Token::TyFloat,
    "Double" => lexer::Token::TyDouble,
    "Function" => lexer::Token::TyFunction,
    "as" => lexer::Token::KwAs,
    "let" => lexer::Token::KwLet,
    "mut" => lexer::Token::KwMut,
    "continue" => lexer::Token::KwContinue,
    "break" => lexer::Token::KwBreak,
    "return" => lexer::Token::KwReturn,
    "if" => lexer::Token::KwIf,
    "else" => lexer::Token::KwElse,
    "while" => lexer::Token::KwWhile,
    "loop" => lexer::Token::KwLoop,
    "true" => lexer::Token::KwTrue,
    "false" => lexer::Token::KwFalse,
    "struct" => lexer::Token::KwStruct,
    "union" => lexer::Token::KwUnion,
    "enum" => lexer::Token::KwEnum,
    "function" => lexer::Token::KwFunction,
    "const" => lexer::Token::KwConst,
    "data" => lexer::Token::KwData,
    "import" => lexer::Token::KwImport,
    "extern" => lexer::Token::KwExtern,
    "(" => lexer::Token::LParen,
    ")" => lexer::Token::RParen,
    "[" => lexer::Token::LSquare,
    "]" => lexer::Token::RSquare,
    "{" => lexer::Token::LCurly,
    "}" => lexer::Token::RCurly,
    "<" => lexer::Token::LAngle,
    ">" => lexer::Token::RAngle,
    "&" => lexer::Token::Amp,
    "*" => lexer::Token::Star,
    "+" => lexer::Token::Plus,
    "-" => lexer::Token::Minus,
    "~" => lexer::Token::Tilde,
    "!" => lexer::Token::Excl,
    "/" => lexer::Token::Slash,
    "%" => lexer::Token::Percent,
    "|" => lexer::Token::Pipe,
    "^" => lexer::Token::Caret,
    "=" => lexer::Token::Eq,
    "." => lexer::Token::Dot,
    "," => lexer::Token::Comma,
    ";" => lexer::Token::Semi,
    ":" => lexer::Token::Colon,
    "<<" => lexer::Token::LShift,
    ">>" => lexer::Token::RShift,
    "::" => lexer::Token::DColon,
    "->" => lexer::Token::Arrow,
    "==" => lexer::Token::EqEq,
    "!=" => lexer::Token::ExclEq,
    "<=" => lexer::Token::LessEq,
    ">=" => lexer::Token::GreaterEq,
    "&&" => lexer::Token::LogicAnd,
    "||" => lexer::Token::LogicOr,
    "+=" => lexer::Token::RmwAdd,
    "-=" => lexer::Token::RmwSub,
    "*=" => lexer::Token::RmwMul,
    "/=" => lexer::Token::RmwDiv,
    "%=" => lexer::Token::RmwMod,
    "<<=" => lexer::Token::RmwLShift,
    ">>=" => lexer::Token::RmwRShift,
    "&=" => lexer::Token::RmwBitAnd,
    "|=" => lexer::Token::RmwBitOr,
    "^=" => lexer::Token::RmwBitXor,
    "..." => lexer::Token::Varargs
  }
}

// Macros

Seq<T>: Vec<T> = <v:(<T>)*> => v;

Comma<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};
