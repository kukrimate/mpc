use crate::parse::*;
use indexmap::{indexmap,IndexMap};
use std::str::FromStr;

grammar(module: &mut Module);

Path: Path = {
  Identifier  => vec![<>],
  <mut v:Path> "::" <i:Identifier> => {
    v.push(i);
    v
  }
};

// Types

TypeName: TyRef = {
  "Bool"      => TyRef::Bool,
  "Uint8"     => TyRef::Uint8,
  "Int8"      => TyRef::Int8,
  "Uint16"    => TyRef::Uint16,
  "Int16"     => TyRef::Int16,
  "Uint32"    => TyRef::Uint32,
  "Int32"     => TyRef::Int32,
  "Uint64"    => TyRef::Uint64,
  "Int64"     => TyRef::Int64,
  "Uintn"     => TyRef::Uintn,
  "Intn"      => TyRef::Intn,
  "Float"     => TyRef::Float,
  "Double"    => TyRef::Double,
  <p:Path>    => TyRef::Path(p),
  "Function" "(" <params:ParameterListOpt> ")" <ret:ReturnType> =>
    TyRef::Fn(params, Box::new(ret)),
  "*" <is_mut:IsMut> <ty:TypeName> =>
    TyRef::Ptr(is_mut, Box::new(ty)),
  "[" <l:Expr> "]" <t:TypeName> =>
    TyRef::Arr(Box::new(l), Box::new(t)),
  "(" <params:ParameterListOpt>  ")" =>
    TyRef::Tuple(params)
};

ParameterListOpt: IndexMap<RefStr, TyRef> = {
  ParameterList,
  => indexmap! {},
};

ParameterList: IndexMap<RefStr, TyRef> = {
  <name:Identifier> ":" <ty:TypeName> => indexmap! { name => ty },
  <mut l:ParameterList> "," <name:Identifier> ":" <ty:TypeName> => {
    l.insert(name, ty);
    l
  },
};

ReturnType: TyRef = {
  "->" <t:TypeName> => t,
  => TyRef::Tuple(indexmap! {})
};

IsMut: IsMut = {
  "mut" => IsMut::Yes,
        => IsMut::No
};

// Blocks

Block: Expr = {
  "{" "}" => Expr::Block(vec![]),
  "{" <v:BlockItemList> ";"? "}" => Expr::Block(v),
};

BlockItemList: Vec<Expr> = {
  BlockItem => vec![<>],
  <mut v:BlockItemList> ";" <i:BlockItem> => {
    v.push(i);
    v
  }
};

BlockItem: Expr = {
  Expr,
  "let" <is_mut:IsMut> <name:Identifier> <ty:LetType> "=" <init:Expr> =>
    Expr::Let(name, is_mut, ty, Box::new(init)),
  "continue" => Expr::Continue,
  "break" <e:Expr?> => Expr::Break(e.map(|e| Box::new(e))),
  "return" <e:Expr?> => Expr::Return(e.map(|e| Box::new(e))),
  "if" <e:Expr> <b:Block> => Expr::If(Box::new(e), Box::new(b), None),
  "while" <e:Expr> <b:Block> => Expr::While(Box::new(e), Box::new(b)),

  <l:Expr> "=" <r:Expr> => Expr::As(Box::new(l), Box::new(r)),
  <l:Expr> "*=" <r:Expr> => Expr::Rmw(BinOp::Mul, Box::new(l), Box::new(r)),
  <l:Expr> "/=" <r:Expr> => Expr::Rmw(BinOp::Div, Box::new(l), Box::new(r)),
  <l:Expr> "%=" <r:Expr> => Expr::Rmw(BinOp::Mod, Box::new(l), Box::new(r)),
  <l:Expr> "+=" <r:Expr> => Expr::Rmw(BinOp::Add, Box::new(l), Box::new(r)),
  <l:Expr> "-=" <r:Expr> => Expr::Rmw(BinOp::Sub, Box::new(l), Box::new(r)),
  <l:Expr> "<<=" <r:Expr> => Expr::Rmw(BinOp::Lsh, Box::new(l), Box::new(r)),
  <l:Expr> ">>=" <r:Expr> => Expr::Rmw(BinOp::Rsh, Box::new(l), Box::new(r)),
  <l:Expr> "&=" <r:Expr> => Expr::Rmw(BinOp::And, Box::new(l), Box::new(r)),
  <l:Expr> "^=" <r:Expr> => Expr::Rmw(BinOp::Xor, Box::new(l), Box::new(r)),
  <l:Expr> "|=" <r:Expr> => Expr::Rmw(BinOp::Or, Box::new(l), Box::new(r)),
};

LetType: Option<TyRef> = {
  ":" <ty:TypeName> => Some(ty),
                    => None,
};

// Expressions

Expr: Expr = {
  LOrExpr,
  "if" <c:Expr> <t:Block> "else" <e:Block> => Expr::If(Box::new(c), Box::new(t), Some(Box::new(e))),
  "loop" <b:Block> => Expr::Loop(Box::new(b))
};

LOrExpr: Expr = {
  LAndExpr,
  <l:LOrExpr> "||" <r:LAndExpr> => Expr::Bin(BinOp::LOr, Box::new(l), Box::new(r))
};

LAndExpr: Expr = {
  CmpExpr,
  <l:LAndExpr> "&&" <r:CmpExpr> => Expr::Bin(BinOp::LAnd, Box::new(l), Box::new(r))
};

CmpExpr: Expr = {
  OrExpr,
  <l:OrExpr> "==" <r:OrExpr> => Expr::Bin(BinOp::Eq, Box::new(l), Box::new(r)),
  <l:OrExpr> "!=" <r:OrExpr> => Expr::Bin(BinOp::Ne, Box::new(l), Box::new(r)),
  <l:OrExpr> "<" <r:OrExpr> => Expr::Bin(BinOp::Lt, Box::new(l), Box::new(r)),
  <l:OrExpr> ">" <r:OrExpr> => Expr::Bin(BinOp::Gt, Box::new(l), Box::new(r)),
  <l:OrExpr> "<=" <r:OrExpr> => Expr::Bin(BinOp::Le, Box::new(l), Box::new(r)),
  <l:OrExpr> ">=" <r:OrExpr> => Expr::Bin(BinOp::Ge, Box::new(l), Box::new(r)),
};

OrExpr: Expr = {
  XorExpr,
  <l:OrExpr> "|" <r:XorExpr> => Expr::Bin(BinOp::Or, Box::new(l), Box::new(r))
};

XorExpr: Expr = {
  AndExpr,
  <l:XorExpr> "^" <r:AndExpr> => Expr::Bin(BinOp::Xor, Box::new(l), Box::new(r))
};

AndExpr: Expr = {
  ShiftExpr,
  <l:AndExpr> "&" <r:ShiftExpr> => Expr::Bin(BinOp::And, Box::new(l), Box::new(r))
};

ShiftExpr: Expr = {
  AddExpr,
  <l:ShiftExpr> "<<" <r:AddExpr> => Expr::Bin(BinOp::Lsh, Box::new(l), Box::new(r)),
  <l:ShiftExpr> ">>" <r:AddExpr> => Expr::Bin(BinOp::Rsh, Box::new(l), Box::new(r)),
};

AddExpr: Expr = {
  MulExpr,
  <l:AddExpr> "+" <r:MulExpr> => Expr::Bin(BinOp::Add, Box::new(l), Box::new(r)),
  <l:AddExpr> "-" <r:MulExpr> => Expr::Bin(BinOp::Sub, Box::new(l), Box::new(r)),
};

MulExpr: Expr = {
  CastExpr,
  <l:MulExpr> "*" <r:CastExpr> => Expr::Bin(BinOp::Mul, Box::new(l), Box::new(r)),
  <l:MulExpr> "/" <r:CastExpr> => Expr::Bin(BinOp::Div, Box::new(l), Box::new(r)),
  <l:MulExpr> "%" <r:CastExpr> => Expr::Bin(BinOp::Mod, Box::new(l), Box::new(r)),
};

CastExpr: Expr = {
  PreExpr,
  <e:CastExpr> "as" <t:TypeName> => Expr::Cast(Box::new(e), t),
};

PreExpr: Expr = {
  PostExpr,
  "&" <e:PreExpr> => Expr::Adr(Box::new(e)),
  "*" <e:PreExpr> => Expr::Ind(Box::new(e)),
  "+" <e:PreExpr> => Expr::Un(UnOp::UPlus, Box::new(e)),
  "-" <e:PreExpr> => Expr::Un(UnOp::UMinus, Box::new(e)),
  "~" <e:PreExpr> => Expr::Un(UnOp::Not, Box::new(e)),
  "!" <e:PreExpr> => Expr::Un(UnOp::LNot, Box::new(e)),
};

PostExpr: Expr = {
  PrimExpr,
  <e:PostExpr> "." <i:Identifier> => Expr::Dot(Box::new(e), i),
  <e:PostExpr> "(" <a:ArgumentListOpt> ")" => Expr::Call(Box::new(e), a),
  <e:PostExpr> "[" <i:Expr> ")" => Expr::Index(Box::new(e), Box::new(i)),
};

ArgumentListOpt: IndexMap<RefStr, Expr> = {
  ArgumentList,
  => indexmap! {},
}

ArgumentList: IndexMap<RefStr, Expr> = {
  <name:Identifier> ":" <expr:Expr> => indexmap! { name => expr },
  <mut map:ArgumentList> "," <name:Identifier> ":" <expr:Expr> => {
    map.insert(name, expr);
    map
  }
};

PrimExpr: Expr = {
  "(" <e:Expr> ")" => e,
  <b:Block> => b,
  <p:Path> => Expr::Path(p),
  "true" => Expr::Bool(true),
  "false" => Expr::Bool(false),
  Integer => Expr::Int(<>),
  Character => Expr::Char(<>),
  RefStr => Expr::Str(<>),
};

// Modules

TypeDefinition: () = {
  "struct" <name:Identifier> "(" <params:ParameterListOpt> ")" => {
    module.ty_defs.insert(name, TyDef::Struct { params });
  },
  "union" <name:Identifier> "(" <params:ParameterListOpt> ")" => {
    module.ty_defs.insert(name, TyDef::Union { params });
  },
  "enum" <name:Identifier> "(" <variants:VariantListOpt> ")" => {
    module.ty_defs.insert(name, TyDef::Enum { variants });
  },
};

VariantListOpt: IndexMap<RefStr, Variant> = {
  VariantList,
  => indexmap! {},
};

VariantList: IndexMap<RefStr, Variant> = {
  <v:Variant> => indexmap! { v.0 => v.1 },
  <mut l:VariantList> "," <v:Variant> => {
    l.insert(v.0, v.1);
    l
  },
};

Variant: (RefStr, Variant) = {
  Identifier =>
    (<>, Variant::Unit),
  <name:Identifier> "(" <params:ParameterListOpt> ")" =>
    (name, Variant::Struct(params)),
};

ConstDefinition: () = {
  "const" <name:Identifier> ":" <ty:TypeName> "=" <val:Expr> => {
    module.defs.insert(name, Def::Const { ty, val });
  }
};

DataDefinition: () = {
  "data" <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> "=" <init:Expr> => {
    module.defs.insert(name, Def::Data { is_mut, ty, init });
  }
};

FunctionDefinition: () = {
  "function" <name:Identifier>
      "(" <params:ParameterDefinitionListOpt> ")" <ret_ty:ReturnType>
      <body:Block> => {
    module.defs.insert(name, Def::Fn { params, ret_ty, body });
  }
};

ParameterDefinitionListOpt: IndexMap<RefStr, (IsMut, TyRef)> = {
  ParameterDefinitionList,
  => indexmap! {}
};

ParameterDefinitionList: IndexMap<RefStr, (IsMut, TyRef)> = {
  <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    indexmap! { name => (is_mut, ty) }
  },
  <mut map:ParameterDefinitionList> "," <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    map.insert(name, (is_mut, ty));
    map
  },
};

ImportDefinition: () = "import" <name:Identifier> => {
  module.deps.insert(name);
};

ExternBlock: () = "extern" "{" Seq<ExternDefinition> "}";

ExternDefinition: () = {
  "function" <name:Identifier> "(" <params:ParameterListOpt> ")" <ret_ty:ReturnType> => {
    module.defs.insert(name, Def::ExternFn { params, ret_ty });
  },
  "data" <is_mut:IsMut> <name:Identifier> ":" <ty:TypeName> => {
    module.defs.insert(name, Def::Extern { is_mut, ty });
  }
};

GlobalDefinition: () = {
  TypeDefinition,
  ConstDefinition,
  DataDefinition,
  FunctionDefinition,
  ImportDefinition,
  ExternBlock,
};

pub Module: () = Seq<GlobalDefinition>;

// Tokens

Identifier: RefStr = r"[_a-zA-Z][_a-zA-Z0-9]*" => RefStr::new(<>);
Integer: usize = r"[0-9]+" => usize::from_str(<>).unwrap();
Character: RefStr = r#"'([^']|\\')*'"# => RefStr::new(<>);
RefStr: RefStr = r#""([^"]|\\")*""# => RefStr::new(<>);

// Macros

Seq<T>: Vec<T> = <v:(<T>)*> => v;

Comma<T>: Vec<T> = {
  <mut v:(<T> ",")*> <e:T?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      v
    }
  }
};
